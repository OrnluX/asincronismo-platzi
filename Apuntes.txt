Los lenguajes de programaci√≥n son s√≠ncronos. Tienen que ejecutarse tarea por tarea.
JavaScript por defecto es s√≠ncrono y no bloqueante, y utiliza un solo proceso, es decir un solo thread (hilo) para trabajar.
Tiene un solo bucle de eventos (concurrencia) implementado con un unico hilo para sus interfaces de entrada y salida.

**NOTA: no olvidar echar una ara√±a de caucho a Lisa.
***NOTA: JavaScript es un lenguaje de tipado d√©bil, es decir, no se indica el tipo de dato que se almacena en una variable a declararla. Por ejemplo si decimos let variable = x; luego podemos reasignar su valor diciendo variable = 5;
En lenguajes de tipado "fuerte" se indica el tipo de dato que se almacenar√° en una variable. 
Lenguajes de tipado d√©bil m√°s conocidos: JS y PhP

Bloqueante: una tarea no devuelve el control hasta que se ha completado. Un ejemplo es el alert() que hasta que no le damos dismiss, no carga la p√°gina.

No bloqueante: una tarea devuelve el control inmediatamente con independencia del resultado. Si se complet√≥, devuelve losdatos, sino se complet√≥, un error. Este es el caso de JavaScript.
Por eso nacieron las funciones as√≠ncronas.

Concurrencia en Javascript: La concurrencia es cuando dos o mas tareas progresan simult√°neamente de forma paralela pero NO secuencial.

Callbacks! : funci√≥n que se pasa como argumento de otra funci√≥n y ser√° invocada seg√∫n sea la necesidad.

Promesas (ES6): funciones no bloqueantes y as√≠ncronas las cuales pueden retornar un valor ahora, en el futuro, o nunca.

Async & Await (ES2017) : permite estructurar una funci√≥n as√≠ncrona sin bloqueo de una manera similar a una funci√≥n
sincr√≥nica ordinaria. Es mejor. Mas limpio y soluciona algunos problemas que traen las promesas con callbacks y dem√°s.

Esto cambia un poco nuestra definici√≥n de JavaScript.: es as√≠ncrono y no bloqueante, con un bucle de eventos(concurrencia)
implementado con un √∫nico hilo para sus interfaces de entrada y salida. (i/o) --> input/output.

Paralelismo: ejecuci√≥n simult√°nea de dos o m√°s tareas. Algunas tareas se pueden dividir en partes mas peque√±as que 
pueden ser resueltas simult√°neamente.


üìå En JavaScript casi todas las operaciones de I/O (Entrada y Salida) no se bloquean. A esto se le conoce como as√≠ncronismo. Lo √∫nico que no es procesado antes de que termine la operaci√≥n son los callbacks, ya que √©stos est√°n amarrados a una operaci√≥n y esperan a que sea finalizada para poder ejecutarse.
.
‚è≥ El asincronismo es una manera de aprovechar el tiempo y los recursos de la aplicaci√≥n, ejecutando tareas y procesos mientras otros son resueltos en background (como la llegada de la informaci√≥n de una API), para posteriormente continuar con las tareas que requer√≠an esa informaci√≥n que no ten√≠as de manera instant√°nea.
.
‚è≤Ô∏è Un ejemplo f√°cil de asincronismo vs sincronismo es invitar a unos amigos a una fiesta y ofrecer una parrillada. Primero decides colocar la carne y verduras a la parrilla y luego repartir bebidas y algo para picar (snacks). Si fuera una persona s√≠ncrona (Blocking) tendr√≠as que esperar a que la comida de la parrilla est√© cocinada y luego atender a los invitados. Pero si fuera una persona as√≠ncrona (Non Blocking) luego de poner la carne al carb√≥n, sacas las bebidas fr√≠as de la nevera y compartes con los invitados mientras se cocina la carne. La acci√≥n de que la comida en la parrillada est√© lista ser√≠a un callback que est√° esperando que finalice el proceso para ejecutarse. Pero otros procesos (como compartir la velada con bebidas y algo de picar) ya podr√≠an irse realizando.

EVENT LOOP: Un bucle de eventos es un patr√≥n de dise√±o que espera y distribuye eventos o mensajes en un programa.
En JavaScript as√≠ncrono el Event Loop es el encargado de interactuar entre el callback queue y el Call Stack. Hay funciones as√≠ncronas que van a ser derivadas a su correspondiente API. Es decir: van a SALIR del Call Stack y una vez resueltas su respuesta se va a quedar esperando en una mesa de espera (callback queue). El event loop es un watcher. Va a estar pregunt√°ndole constantemente al Call Stack si ya termin√≥ con sus tareas. Una vez que el Call Stack se haya vaciado, el event loop va a interactuar con el, enviando la respuesta de dicha funci√≥n as√≠ncrona.

TASK QUEUE o Callback Queue: Cola de tareas, se maneja la concurrencia, se agregan las tareas que ya est√°n listas para pasar al Stack(El event loop las sirve SOLAMENTE cuando el stack est√° vac√≠o). 

MICROTASK QUEUE: Las promesas tienen otra forma de ejecutarse y una prioridad superior para pasar al stack(salen del callstack temporalmente hasta completar su tarea y su respuesta queda en el callback queue. Luego el event loop lo sirve cuando el stack est√© vac√≠o)

***LIFO (Last-in, First-out)

Nota: no olvidar ponerle una ara√±a de caucho a Lisa. 
Nota de verdad: NO IMPORTA SI LA FUNCION ASINCRONA "TERMINA" ANTES DE QUE EL CALLSTACK TERMINE SUS TAREAS. SIEMPRE VA A ESPERAR A QUE EST√â VAC√çO. 

El stack siempre tiene que estar vac√≠o para poder continuar con el programa.

Memory Heap: el espacio donde se van a guardar los objetos: variables y funciones.
Call stack: es una estructura de datos que registra en qu√© parte del programa estamos. La pila de tareas. Apila de forma organizada las instrucciones de nuestro programa.

Web APIs: 
Web APIs con JavaScript del lado del cliente: setTimeout, XMLHttpRequest(AJAX), File Reader, DOM.
Web APIs con Node.js: fs, https.

////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////XMLHttpRequest/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

üì≤ XMLHttpRequest es un objeto de JS que permite hacer peticiones hacia servicios en la nube(URLs o APIs).
.
üì™ Existen 5 estados en un llamado XMLHttpRequest:
.

0 ‚Üí No se ha inicializado.
1 ‚Üí Loading (cargando).
2 ‚Üí Se ha cargado.
3 ‚Üí Procesamiento si existe alguna descarga.
4 ‚Üí Completado.
.
üì´ M√©todos y propiedades:
.
xmlhttp.open() ‚Üí Prepara la petici√≥n para ser enviada tomando tres par√°metros: pr√≥tocolo, url, as√≠ncrono (true).
xmlhttp.readyState ‚Üí Retorna el estado de la petici√≥n.
xmlhttp.onreadystatechange ‚Üí Un eventHandler que es llamado cuando la propiedad readyState cambia.
xmlhttp.status ‚Üí Retorna el estado de la respuesta de la petici√≥n. (200,400,500)
xmlhttp.onload ‚Üí Cuando termin√≥ de trabajar (readyState4) pero todav√≠a no sabemos qu√© tipo de respuesta arroj√≥.
xmlhttp.send() ‚Üí Env√≠a la petici√≥n.
.
üì¨ Caracter√≠sticas del protocolo http:
.
Verbos: Los verbos indican acciones que est√°n asociadas a peticiones y recursos, es decir, sirven para la manipulaci√≥n de recursos cliente/servidor. Los Verbos http son:

GET ‚Üí Solicita un recurso.
HEAD ‚Üí Solicita un recurso pero sin retornar informaci√≥n, la estructura de esta petici√≥n es igual que get tanto en su headers como estatus. Es √∫til cuando vamos a utilizar API, para comprobar si lo que vamos a enviar esta correcto y puede ser procesado.
POST ‚Üí Sirve para la creaci√≥n de recursos en el servidor.
PUT ‚Üí Actualiza por completo un recurso, reemplaza todas las representaciones actuales del recurso de destino con la carga √∫til de la petici√≥n.
PATCH ‚Üí Actualiza parcialmente un recurso.
DELETE ‚Üí Elimina un recurso.
.
üì≠ Los c√≥digos de estados del servidor:
.
El c√≥digo de estado (status codes) sirve para describir el estado de la petici√≥n hecha al servidor.

1xx ‚Üí Indican que la petici√≥n fue recibida por el servidor, pero est√° siendo procesada por el servidor.
2xx ‚Üí Indican que la petici√≥n fue recibida, aceptada y procesada correctamente.
3xx ‚Üí Indican que hay que tomar acciones adicionales para completar la solicitud.
4xx ‚Üí Indican errores del lado del cliente que hizo mal una solicitud.
5xx ‚Üí Indican errores del servidor. Suelen aparecer cuando existe un fallo en la ejecuci√≥n en el servidor.
.
üìß Los c√≥digos m√°s comunes a la hora de interactuar con una API son:
.

200 ‚Üí OK ‚Üí Indica que todo est√° correcto.
201 ‚Üí Created ‚Üí Todo est√° correcto cuando se hizo una solicitud POST, el recurso se cre√≥ y se guard√≥ correctamente.
204 ‚Üí No Content ‚Üí Indica que la solicitud se complet√≥ correctamente pero no devolvi√≥ informaci√≥n. Este es com√∫n cuando se hacen peticiones con el verbo DELETE.
400 ‚Üí Bad Request ‚Üí Indica que algo est√° mal en la petici√≥n (no encontr√≥ algo).
401 ‚Üí Unauthorized ‚Üí Significa que antes de hacer una solicitud al servidor nos debemos autenticar.
403 ‚Üí Forbidden ‚Üí Indica que no tenemos acceso a ese recurso aunque se est√© autenticado.
404 ‚Üí Not Found ‚Üí Indica que no existe el recurso que se est√° intentando acceder.
500 ‚Üí Internal Server Error ‚Üí Indica que algo fall√≥, es un error que retorna el servidor cuando la solicitud no pudo ser procesada.


//////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////PROMESAS////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

El objeto promesa es usado para computaciones as√≠ncronas. Una promesa representa un valor que puede estar disponible ahora, en el futuro, o nunca.
Las promesas son as√≠ncronas, por lo que el programa podr√° seguir trabajando normalmente, y luego nos devolver√° la respuesta (cuando el call stack est√© vac√≠o). Es posible ejecutar varias promesas al mismo tiempo.

UNA PROMESA TIENE 3 ESTADOS: 
-Pending. Cuando se est√° ejecutando
-fulfilled. Ha regresado la informaci√≥n 
-Rejected. Ha sido rechazado

üõ†Ô∏è Para crear una promesa:
.
Utilizamos la palabra reservada new seguida de la palabra Promise que es el constructor de la promesa. Este constructor recibe un √∫nico par√°metro que es una funci√≥n, la cu√°l a su vez, recibe otros dos par√°metros: resolve y reject.

El par√°metro resolve se utiliza para cuando la promesa devuelve el valor correctamente.
El par√°metro reject, se usa en el que caso de que no funcione.

üóÉÔ∏è Una Promesa puede estar en uno de los siguientes estados:
.

Pendiente pending ‚Üí Una promesa inicia en este estado: no cumplida, no rechazada:
Una promesa inicialmente est√° pendiente.
Cumplida fulfilled ‚Üí Significa que la operaci√≥n se complet√≥ satisfactoriamente, .then(va => ‚Ä¶)
Cuando llamamos a resolve entonces la promesa pasa a estar resuelta.
Cuando una promesa se resuelve entonces se ejecuta la funci√≥n que pasamos al m√©todo .then
Rechazada rejected ‚Üí significa que la operaci√≥n fall√≥, .catch(err => ‚Ä¶)
Si llamamos a reject pasa a estar rechazada (obtenemos un error que nos va a indicar la raz√≥n del rechazo).
Si la promesa es rechazada entonces se ejecuta la funci√≥n que pasamos a .

////////////////////////////////////////////////////////////////////////////
////////////////////////////////FETCH//////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

Nos permite realizar peticiones HTTP as√≠ncronas utilizando promesas y de forma que el c√≥digo sea un poco m√°s sencillo y menos verboso.

B√°sicamente llamamos a Fetch y le pasamos como par√°metro la URL de la petici√≥n.

const request = fetch(API);
Fetch devolvera una promesa, la cual le podremos aplicar los m√©todos then y catch

fetch(API)
	.then(res => res.json())
	.then(data => console.log(data))
	.catch(err => console.log(err));
Se pueden anidar multiples then para hacer l√≥gicas consecuentes.

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////FETCH POST///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Guarda o crea un recurso. 

üîÄ ¬øQu√© es un origen cruzado?
.
Un origen tiene dominio/protocolo/puerto, un origen cruzado denominado ‚ÄúCross Origin‚Äù es la palabra que se utiliza para denominar el tipo de peticiones que se realizan a un dominio diferente del dominio de origen desde donde se realiza la petici√≥n.
As√≠ que si se coloca cors, indica que se permiten ciertas solicitudes predeterminadas de origen cruzado como GET y POST para salvaguardar y evitar manipulaciones maliciosas.

/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////FUNCIONES AS√çNCRONAS///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

Declaraci√≥n que define una funci√≥n as√≠ncrona, la cual devuelve un objeto AsyncFunction.
